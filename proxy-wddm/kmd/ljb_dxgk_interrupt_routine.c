/*
 * ljb_dxgk_interrupt_routine.c
 *
 * Author: Lin Jiabang (lin.jiabang@gmail.com)
 *     Copyright (C) 2016  Lin Jiabang
 *
 *  This program is NOT free software. Any unlicensed usage is prohbited.
 */
#include "ljb_proxykmd.h"

/*
 * Function: LJB_DXGK_InterruptRoutine
 *
 * Description:
 * The DxgkDdiInterruptRoutine function handles interrupts generated by a display adapter.
 *
 * Return Value:
 * If DxgkDdiInterruptRoutine determines that the adapter represented by
 * MiniportDeviceContext did not generate the interrupt, it returns FALSE.
 * Otherwise, it must dismiss the interrupt on the adapter before it returns TRUE.
 *
 * Remarks:
 * If the interrupt is line-based (MessageNumber = 0), DxgkDdiInterruptRoutine
 * must determine whether the adapter represented by MiniportDeviceContext
 * generated the interrupt and, if not, return FALSE immediately.
 *
 * If the adapter represented by MiniportDeviceContext did generate the interrupt,
 * then DxgkDdiInterruptRoutine should the following steps:
 *
 * Dismiss the interrupt on the adapter.
 *
 * Complete the requested operation that caused the interrupt, or queue a DPC
 * that will complete the operation later.
 *
 * Return TRUE as quickly as possible.
 *
 * Any other display miniport driver function that shares memory (for example,
 * some portion of the state represented by MiniportDeviceContext) with
 * DxgkDdiInterruptRoutine must call DxgkCbSynchronizeExecution to synchronize
 * its access to the shared memory.
 *
 * The DxgkDdiInterruptRoutine function can call DxgkCbQueueDpc and
 * DxgkCbNotifyInterrupt but must not call any other DxgkCbXxx functions. For
 * more information on the proper sequence of function calls, see Submitting a
 * Command Buffer.
 *
 * DxgkDdiInterruptRoutine runs at an elevated IRQL, so it (and all the functions
 * it calls) must be non-pageable. Also, DxgkDdiInterruptRoutine (and all the
 * functions it calls) must not attempt to access pageable memory.
 */
BOOLEAN
LJB_DXGK_InterruptRoutine(
    _In_ const PVOID MiniportDeviceContext,
    _In_       ULONG MessageNumber
    )
{
    LIST_ENTRY * CONST          listHead = &GlobalDriverData.ClientAdapterListHead;
    LIST_ENTRY *                listEntry;
    LJB_ADAPTER *               Adapter;
    LJB_CLIENT_DRIVER_DATA *    ClientDriverData;
    DRIVER_INITIALIZATION_DATA* DriverInitData;
    BOOLEAN                     retValue;

    Adapter = NULL;
    for (listEntry = listHead->Flink;
         listEntry != listHead;
         listEntry = listEntry->Flink)
    {
        LJB_ADAPTER * thisAdapter;

        thisAdapter = CONTAINING_RECORD(listEntry, LJB_ADAPTER, ListEntry);
        if (thisAdapter->hAdapter == MiniportDeviceContext)
        {
            Adapter = thisAdapter;
            break;
        }
    }

    if (Adapter == NULL)
    {
        KdPrint(("?" __FUNCTION__
            ": no Adapter found for MiniportDeviceContext(%p)\n",
            MiniportDeviceContext
            ));
        return FALSE;
    }

    ClientDriverData = Adapter->ClientDriverData;
    DriverInitData = &ClientDriverData->DriverInitData;

    retValue = (*DriverInitData->DxgkDdiInterruptRoutine)(
        MiniportDeviceContext,
        MessageNumber
        );

    return retValue;
}
